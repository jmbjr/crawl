###############################################################################
# layout_cryptic_divisions.des: A layout_type_divisions layout for Crypt:$
#                     
###############################################################################
# Required file contains overview of geoelf room placement
: require("dlua/layout/geoelf.lua")

{{
  --
  -- Constants
  --
  -- These have to be global so they can also be used in the
  --  veto function.
  --

  -- size of castle
  CASTLE_INNER        = 4
  CASTLE_HALLWAY      = 3
  CASTLE_MOAT         = 2
  CASTLE_OPEN         = 1
  CASTLE_OVERWRITABLE = 3
  CASTLE_TOTAL        = CASTLE_INNER + CASTLE_HALLWAY      + CASTLE_MOAT +
                        CASTLE_OPEN  + CASTLE_OVERWRITABLE
  CASTLE_TURRET_RADIUS      = 4
  CASTLE_TURRET_MOAT_RADIUS = CASTLE_TURRET_RADIUS + CASTLE_MOAT
  CASTLE_TURRET_OPEN_RADIUS = CASTLE_TURRET_MOAT_RADIUS + CASTLE_OPEN
  CASTLE_TURRET_OVERWRITABLE_RADIUS = CASTLE_HALLWAY + CASTLE_MOAT         +
                                      CASTLE_OPEN    + CASTLE_OVERWRITABLE - 1

  INNER_WALL_SPACING_MIN = 6
  INNER_WALL_SPACING_MAX = 12

  GATE_FROM_CORNER_MIN = 8
  GATE_SIZE_MIN = 2
  GATE_SIZE_MAX = 3

  -- room parameters
  ROOMS_OFFSET_MAX      = 1
  ROOMS_RADIUS_MIN      = 3
  ROOMS_RADIUS_MAX      = 5
  ROOMS_RADIUS_EDGE_MIN = 2
  ROOMS_RADIUS_EDGE_MAX = 4
  ROOMS_EXTRA_CORRIDOR_FRACTION = 0.5
  ROOMS_FANCY_ROOM_FRACTION     = 0.2

  -- room placement
  ROOMS_BORDER_MIN  = ROOMS_OFFSET_MAX + ROOMS_RADIUS_MAX + 1
  ROOMS_FROM_CASTLE = ROOMS_OFFSET_MAX + ROOMS_RADIUS_MAX + 1
  ROOMS_SPACING_MIN = ROOMS_OFFSET_MAX + ROOMS_RADIUS_MAX * 2 + 2
  ROOMS_INTO_CASTLE = ROOMS_SPACING_MIN - ROOMS_FROM_CASTLE
  ROOMS_MIN_SPACE   = CASTLE_TOTAL + ROOMS_BORDER_MIN + ROOMS_FROM_CASTLE

  -- veto tests
  PRIMARY_VAULT_MIN_PADDING = ROOMS_MIN_SPACE + 1
  PRIMARY_VAULT_MIN_SIZE    = GATE_FROM_CORNER_MIN + GATE_SIZE_MAX
                              - CASTLE_HALLWAY - CASTLE_INNER

  -- edge rows of rooms have no individual offset to allow
  --  for maximum distance from grid
  ROOMS_SPACING_EDGE   = math.ceil(ROOMS_SPACING_MIN / 2) + 1
  ROOMS_MIN_SPACE_EDGE = ROOMS_SPACING_EDGE + ROOMS_RADIUS_EDGE_MAX + 2

  DEBUG_CASTLE_DESIGN = false
}}

##############################################################
# layout_cryptic_divisions
#
# These are either very randomized encompass vaults, or
# subvault-based layouts.  Take your pick.
#
# Inspired by layout_pan_divisions.
#
# Theses are the only layout_type_divisions layout in
# Crypts and are intended to have a total weight of ToDo.
# If more forms or other layout_type_divisions layouts are
# added to the branch, the existing weights should be adjusted
# to avoid increasing the total weight.
#



##############################################################
# layout_cryptic_divisions_a
#
# This is the original cryptic_divisions layout.
#
# This layout uses 8 subvaults to place a maze of adjoining
# rooms.  There are 2 big subvaults, 2 thin subvaults, and 4 
# small subvaults. 
# Subvaults should have randomization and the
# allow_dup tag.  
#
# Quadrants for this map should have the tag
# "cryptic_division_quadrant_a".
#
#
NAME:     layout_cryptic_divisions_a
DEPTH:    Crypt:$
WEIGHT:   9999
ORIENT:   encompass
TAGS:     overwritable layout allow_dup unrand layout_type_divisions
SUBVAULT: A : cryptic_division_big
SUBVAULT: B : cryptic_division_thin
SUBVAULT: C : cryptic_division_small
SUBVAULT: D : cryptic_division_small
SUBVAULT: E : cryptic_division_big
SUBVAULT: F : cryptic_division_thin
SUBVAULT: G : cryptic_division_small
SUBVAULT: H : cryptic_division_small
SUBST: ABCDEFGH = .
{{
  --
  --  PHASE 1: Resize the map to maximal size.
  --

  local gxm, gym = dgn.max_bounds()
  crawl.mpr("resizing map to maximal size")
  crawl.mpr(gxm)
  crawl.mpr(gym)
  extend_map{width = gxm, height = gym, fill = 'x'}

  --
  --  PHASE 2: Choose design and placement of castle and rooms
  --           based on primary vault
  --

  -- choose which sides of primary vault have castle and rooms
  local p_x_min, p_x_max, p_y_min, p_y_max = primary_vault_dimensions()
  if (p_x_min == nil) then
    crawl.mpr("layout_geoelf_castle didn't veto for no primary vault")
    return true  -- no primary vault
  else
    crawl.mpr("Primary Vault Coords")
    crawl.mpr(p_x_min)
    crawl.mpr(p_x_max)
    crawl.mpr(p_y_min)
    crawl.mpr(p_y_max)

  end

  local primary_vault = { bounds = {}, border = {} }
  primary_vault.bounds[geoelf.directions.W] = p_x_min
  primary_vault.bounds[geoelf.directions.E] = p_x_max
  primary_vault.bounds[geoelf.directions.N] = p_y_min
  primary_vault.bounds[geoelf.directions.S] = p_y_max
  primary_vault.border[geoelf.directions.W] =       p_x_min - 1
  primary_vault.border[geoelf.directions.E] = gxm - p_x_max - 2
  primary_vault.border[geoelf.directions.N] =       p_y_min - 1
  primary_vault.border[geoelf.directions.S] = gym - p_y_max - 2

  local is_castle = {}
  local is_rooms  = {}
  local gate_best = nil
  local gate_best_space = 0

  for i = 0, geoelf.directions.COUNT_STRAIGHT - 1 do
    is_castle[i] = (primary_vault.border[i] >= CASTLE_TOTAL)
    is_rooms[i]  = (primary_vault.border[i] >= ROOMS_MIN_SPACE)

  -- put the castle gate on the side with most space
    if (primary_vault.border[i] > gate_best_space) then
      gate_best = i
      gate_best_space = primary_vault.border[i]
    end
  end

  -- skip phase 3 for now

  --
  --  PHASE 4: Choose which rooms to add to the basic grid
  --           outside the castle
  --

  local edge_rooms = {}

  -- spacing of north and south rooms along x axis
  local min_x = castle.overwritable[geoelf.directions.W] + ROOMS_INTO_CASTLE
  local max_x = castle.overwritable[geoelf.directions.E] - ROOMS_INTO_CASTLE
  local range_x = max_x - min_x
  edge_rooms.count_x = math.floor(range_x / ROOMS_SPACING_MIN) + 1
  local range_x_min = (edge_rooms.count_x - 1) * ROOMS_SPACING_MIN
  edge_rooms.spacing_x = ROOMS_SPACING_MIN
  edge_rooms.allow_diagonals_x = true

  if (is_rooms[geoelf.directions.W]) then
    if (is_rooms[geoelf.directions.E]) then
      -- spread out the rooms to connect on both sides
      --  -> this prevents diagonal connections on the side
      edge_rooms.min_x = min_x
      edge_rooms.spacing_x = range_x / (edge_rooms.count_x - 1)
      edge_rooms.allow_diagonals_x = false
    else
      -- pack the rooms against the west side
      edge_rooms.min_x = min_x
    end
  else
    if (is_rooms[geoelf.directions.E]) then
      -- pack the rooms against the east side
      edge_rooms.min_x = max_x - range_x_min
    else
      -- center the rooms
      local min_x_max = max_x - range_x_min
      edge_rooms.min_x = math.floor((min_x + min_x_max) / 2)
    end
  end

  -- spacing of east and west rooms along x axis
  local min_y = castle.overwritable[geoelf.directions.N] + ROOMS_INTO_CASTLE
  local max_y = castle.overwritable[geoelf.directions.S] - ROOMS_INTO_CASTLE
  local range_y = max_y - min_y
  edge_rooms.count_y = math.floor(range_y / ROOMS_SPACING_MIN) + 1
  local range_y_min = (edge_rooms.count_y - 1) * ROOMS_SPACING_MIN
  edge_rooms.spacing_y = ROOMS_SPACING_MIN
  edge_rooms.allow_diagonals_y = true

  if (is_rooms[geoelf.directions.N]) then
    if (is_rooms[geoelf.directions.S]) then
      -- spread out the rooms to connect on both sides
      --  -> this prevents diagonal connections on the side
      edge_rooms.min_y = min_y
      edge_rooms.spacing_y = range_y / (edge_rooms.count_y - 1)
      edge_rooms.allow_diagonals_y = false
    else
      -- pack the rooms against the east side
      edge_rooms.min_y = min_y
    end
  else
    if (is_rooms[geoelf.directions.S]) then
      -- pack the rooms against the west side
      edge_rooms.min_y = max_y - range_y_min
    else
      -- center the rooms
      local min_y_max = max_y - range_y_min
      edge_rooms.min_y = math.floor((min_y + min_y_max) / 2)
    end
  end

  -- calculate row positions
  edge_rooms.row_base = {}
  edge_rooms.row_base[geoelf.directions.W] =
                   castle.overwritable[geoelf.directions.W] - ROOMS_FROM_CASTLE
  edge_rooms.row_base[geoelf.directions.E] =
                   castle.overwritable[geoelf.directions.E] + ROOMS_FROM_CASTLE
  edge_rooms.row_base[geoelf.directions.N] =
                   castle.overwritable[geoelf.directions.N] - ROOMS_FROM_CASTLE
  edge_rooms.row_base[geoelf.directions.S] =
                   castle.overwritable[geoelf.directions.S] + ROOMS_FROM_CASTLE

  edge_rooms.row_count = {}
  for i = 0, geoelf.directions.COUNT_STRAIGHT - 1 do
    if (is_rooms[i] == false) then
      edge_rooms.row_count[i] = 0
    else
      local available_space = primary_vault.border[i]
                              - (ROOMS_FROM_CASTLE + ROOMS_BORDER_MIN) + 1
      edge_rooms.row_count[i] = math.floor(available_space / ROOMS_SPACING_MIN)
      if (edge_rooms.row_count[i] <= 0) then
        crawl.mpr("Error in layout_geoelf_castle: 0 rows in direction " ..
                  i .. " filling " .. ROOMS_SPACING_MIN .. " / " ..
                  available_space .. " space")
      end
    end
  end

  if (DEBUG_CASTLE_DESIGN) then
    print("Rooms by edge")

    print("  Rooms along castle X: " .. edge_rooms.count_x)
    print("  Rooms along castle X: " .. edge_rooms.count_x)
    print("  Rooms minimum spacing: " .. ROOMS_SPACING_MIN ..
          " (straight),  " .. ROOMS_SPACING_EDGE .. " (diagonal)  + " ..
          ROOMS_BORDER_MIN .. " (border)")

    local LETTERS =
      { [geoelf.directions.S] = "S",
        [geoelf.directions.N] = "N",
        [geoelf.directions.E] = "E",
        [geoelf.directions.W] = "W" }

    for i = 0, geoelf.directions.COUNT_STRAIGHT - 1 do
      local step_sign = geoelf.directions.STEP_SIGN[i]
      local line = "  " .. LETTERS[i] .. " " .. edge_rooms.row_count[i] ..
                   (is_rooms[i] and " Y" or " N") .. ": "
      for j = 0, edge_rooms.row_count[i] - 1 do
        local pos = edge_rooms.row_base[i] + j * ROOMS_SPACING_MIN * step_sign
        line = line .. "  " .. pos
      end
      print(line)
    end
  end

  -- combine all x positions into an array
  local room_pos_x = {}
  room_pos_x.begin_center = edge_rooms.row_count[geoelf.directions.W]
  room_pos_x.begin_east   = room_pos_x.begin_center + edge_rooms.count_x
  room_pos_x.total        = room_pos_x.begin_east
                            + edge_rooms.row_count[geoelf.directions.E]
  room_pos_x.last         = room_pos_x.total - 1
  local is_room_diagonals_x = {}
  for i = 0, room_pos_x.total - 1 do
    is_room_diagonals_x[i] = true
    if (i < room_pos_x.begin_center) then
      local rows_out = room_pos_x.begin_center - i - 1
      room_pos_x[i] = edge_rooms.row_base[geoelf.directions.W]
                      - rows_out * ROOMS_SPACING_MIN
    elseif (i < room_pos_x.begin_east) then
      local rows_along = i - room_pos_x.begin_center
      room_pos_x[i] = edge_rooms.min_x
                      + math.floor(rows_along * edge_rooms.spacing_x)
      is_room_diagonals_x[i] = edge_rooms.allow_diagonals_x
    else
      local rows_out = i - room_pos_x.begin_east
      room_pos_x[i] = edge_rooms.row_base[geoelf.directions.E]
                      + rows_out * ROOMS_SPACING_MIN
    end
  end

  -- combine all y positions into an array
  local room_pos_y = {}
  room_pos_y.begin_center = edge_rooms.row_count[geoelf.directions.N]
  room_pos_y.begin_south  = room_pos_y.begin_center + edge_rooms.count_y
  room_pos_y.total        = room_pos_y.begin_south
                            + edge_rooms.row_count[geoelf.directions.S]
  room_pos_y.last         = room_pos_y.total - 1
  local is_room_diagonals_y = {}
  for i = 0, room_pos_y.total - 1 do
    is_room_diagonals_y[i] = true
    if (i < room_pos_y.begin_center) then
      local rows_out = room_pos_y.begin_center - i - 1
      room_pos_y[i] = edge_rooms.row_base[geoelf.directions.N]
                      - rows_out * ROOMS_SPACING_MIN
    elseif (i < room_pos_y.begin_south) then
      local rows_along = i - room_pos_y.begin_center
      room_pos_y[i] = edge_rooms.min_y
                      + math.floor(rows_along * edge_rooms.spacing_y)
      is_room_diagonals_y[i] = edge_rooms.allow_diagonals_y
    else
      local rows_out = i - room_pos_y.begin_south
      room_pos_y[i] = edge_rooms.row_base[geoelf.directions.S]
                      + rows_out * ROOMS_SPACING_MIN
    end
  end

  if (DEBUG_CASTLE_DESIGN) then
    print("Room grid positions")

    local line = "  X " .. room_pos_x.total .. ":"
    for i = 0, room_pos_x.total - 1 do
      line = line .. "  " .. room_pos_x[i]
      if (not is_room_diagonals_x[i]) then
        line = line .. " (NODIAG)"
      end
    end
    print(line)

    local line = "  Y " .. room_pos_y.total .. ":"
    for i = 0, room_pos_y.total - 1 do
      line = line .. "  " .. room_pos_y[i]
      if (not is_room_diagonals_y[i]) then
        line = line .. " (NODIAG)"
      end
    end
    print(line)
  end



}}

MAP
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcBBBBBBBBBBBBBx
xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...AAAAAAAAAAcBBBBBBBBBBBBBx
xccccccccccccccccccccccccccccccccccc+ccccccccccccBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDD...DDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCC.c.DDDDDDDDDDDDDDDDDDDDD.c.BBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCC.+.DDDDDDDDDDDDDDDDDDDDD.+.BBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCC.c.DDDDDDDDDDDDDDDDDDDDD.c.BBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCCCCCcDDDDDDDDDDDDDDDDDDDDDDDcBBBBBBBBBBBBBx
xCCCCCCCCCCCCCCCCCCCC...c...DDDDDDDDDDDDDDDDDDDDcBBBBB...BBBBBx
xccccccccccccccccccccc+ccc+cccccccccccccccccccccccccccc+ccccccx
xEEEEEEEEEEEEEEEEEEEE...E...EEEEEEEEEEEEEEEEEEEEcFFFFF...FFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE.c.FFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE.+.FFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE.c.FFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEcFFFFFFFFFFFFFx
x...EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE...EcFFFFFFFFFFFFFx
xc+cccccccccccccccccccccccccccccccccccccccccc+cccFFFFFFFFFFFFFx
x...GGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHH...HcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGG.c.HHHHHHHHHHHHHHHHHHHHH.c.FFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGG.+.HHHHHHHHHHHHHHHHHHHHH.+.FFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGG.c.HHHHHHHHHHHHHHHHHHHHH.c.FFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xGGGGGGGGGGGGGGGGGGGGGGGcHHHHHHHHHHHHHHHHHHHHHHHcFFFFFFFFFFFFFx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
ENDMAP



# Here in case people want to see or start from an empty
# quadrant for layout_cryptic_divisions_a.  The 'x's are areas that
# are normally not used.
NAME:    cryptic_division_big_base
WEIGHT:  10
TAGS:    cryptic_division_big allow_dup unrand
KMASK:   . = vault
MAP
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
ENDMAP


NAME:    cryptic_division_small_base
WEIGHT:  10
TAGS:    cryptic_division_small allow_dup unrand
KMASK:   . = vault
MAP
.......................
.......................
.......................
.......................
.......................
.......................
.......................
.......................
.......................
.......................
.......................
.......................
.......................
ENDMAP

NAME:    cryptic_division_small_simple
WEIGHT:  99999
TAGS:    cryptic_division_small allow_dup unrand
KMASK:   . = vault
MAP
.......................
.xxxx..xxx...xxx..xxxx.
.......................
.......................
.......................
.xxxx..xxx...xxx..xxxx.
.......................
.......................
.......................
.xxxx..xxx...xxx..xxxx.
.......................
.......................
.......................
ENDMAP


NAME:    cryptic_division_thin_base
WEIGHT:  10
TAGS:    cryptic_division_thin allow_dup unrand
KMASK:   . = vault
MAP
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
.............
ENDMAP

